<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- xterm æ ·å¼ -->
    <link rel="stylesheet" href="qrc:/web/xterm/xterm.css" />

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        #terminal {
            height: 100%;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="terminal"></div>

    <!-- Qt WebChannel è„šæœ¬ -->
    <script src="qrc:/qtwebchannel/qwebchannel.js"></script>

    <!-- xterm.js -->
    <script src="qrc:/web/xterm/xterm.js"></script>

    <!-- xterm.js æ’ä»¶ -->
    <script src="qrc:/web/xterm/xterm-addon-fit.min.js"></script>

    <script>
        var term = null;

        function getChannelName() {
            const params = new URLSearchParams(window.location.search);
            return params.get("channel");
        }

        function setupTerminal(channel) {
            const channelName = getChannelName();
            window.backend = channel.objects[channelName];
            const backend = window.backend;

            if (!backend) {
                console.error("âŒ WebChannel object not found:", channelName);
                const terminalDiv = document.getElementById("terminal");
                terminalDiv.innerText = `âŒ Backend '${channelName}' not found.\nAvailable: ${Object.keys(channel.objects).join(", ")}`;
                return;
            }

            console.log("âœ… Connected to backend:", channelName);

            term = new Terminal({
                cursorBlink: true,
                theme: {
                    background: "#1e1e1e",
                    foreground: "#d4d4d4"
                },
                fontSize: 14,
                scrollback: 1000
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);

            term.open(document.getElementById("terminal"));
            fitAddon.fit();

            // è‡ªåŠ¨é€‚é…çª—å£å˜åŒ–
            window.addEventListener("resize", () => {
                fitAddon.fit();
            });

            // æ¥æ”¶ Qt ç«¯æ–‡æœ¬
            if (backend.receiveText && backend.receiveText.connect) {
                backend.receiveText.connect(function (text) {
                    term.write(text);
                });
            } else {
                console.warn("âš ï¸ backend.receiveText is not a signal");
            }

            // å‘é€è¾“å…¥åˆ° Qt
            term.onData(function (data) {
                if (backend.sendText) {
                    backend.sendText(data);
                } else {
                    console.warn("âš ï¸ backend.sendText is not available");
                }
            });

            term.writeln(`[WebView Engine Initialized]`);
            if (backend.sendText) {
                console.info("[Info] Client connected");
            }
        }

        function initWebChannel() {
            if (typeof QWebChannel === 'undefined' || typeof qt === 'undefined' || !qt.webChannelTransport) {
                console.warn("[Warn] Qt WebChannel transport not ready. Retrying...");
                setTimeout(initWebChannel, 100);
                return;
            }

            new QWebChannel(qt.webChannelTransport, function (channel) {
                console.log("âœ… Qt WebChannel initialized");
                setupTerminal(channel);
            });
        }

        window.addEventListener("DOMContentLoaded", () => {
            initWebChannel();
        });

        window.copyText = function (text) {
            if (!window.term) {
                console.error("âŒ Term not ready");
                return;
            } else {
                console.error("âœ… Copied to QML:", text);
            }
            navigator.clipboard.writeText(text).then(() => {
                console.error("âœ… Copied from QML:", text);
            }).catch(err => {
                console.error("âŒ Copy failed:", err);
            });
        }

        window.pasteFromClipboard = function (text) {
            if (!window.term) {
                console.error("âŒ term æœªå°±ç»ª");
                return;
            }

            if (typeof text !== "string" || text.length === 0) {
                console.error("âŒ ç²˜è´´å†…å®¹ä¸ºç©ºæˆ–æ— æ•ˆ");
                return;
            }

            console.log("ğŸ“‹ QML ä¼ å…¥çš„å‰ªè´´æ¿å†…å®¹ =", text);

            // å‘é€ç»™åç«¯
            if (window.backend && typeof window.backend.sendText === "function") {
                window.backend.sendText(text);
                console.log("ğŸ“¤ å·²å‘é€åˆ° Qt åç«¯");
            } else {
                console.warn("âš ï¸ backend.sendText æœªç»‘å®š");
            }
        };


        window.doCopy = function (text) {
            try {
                // ä»…ç”¨äºè°ƒè¯•
                console.error("Trying copy:", text);
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶ textarea
                const textarea = document.createElement("textarea");
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();

                const success = document.execCommand("copy");
                console.error("execCommand copy success:", success);
                document.body.removeChild(textarea);
            } catch (e) {
                console.error("Legacy copy failed:", e);
            }
        };


    </script>
</body>

</html>